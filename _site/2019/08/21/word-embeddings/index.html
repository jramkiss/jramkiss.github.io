<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>First Steps with Word Embeddings &#8211; Jramkiss Blog</title>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="This post explains the word2vec, GloVe and fasttext algorithms in detail and shows how to use pre-trained models for each in Python's gensim package.">
    <meta name="robots" content="all">
    <meta name="author" content="Jonathan Ramkissoon">
    
    <meta name="keywords" content="">
    <link rel="canonical" href="http://localhost:4000/2019/08/21/word-embeddings/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Jramkiss Blog" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201909191715" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-AMS-MML_HTMLorMML,https://idcrook.github.io/assets/js/MathJaxLocal.js">
</script>

    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="First Steps with Word Embeddings">
    <meta property="og:description" content="This is a test of a website 12345678">
    <meta property="og:url" content="http://localhost:4000/2019/08/21/word-embeddings/">
    <meta property="og:site_name" content="Jramkiss Blog">
    
    <meta property="og:image" content="http://localhost:4000/assets/profile.JPG">
    

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:title" content="First Steps with Word Embeddings" />
    <meta name="twitter:description" content="This post explains the word2vec, GloVe and fasttext algorithms in detail and shows how to use pre-trained models for each in Python's gensim package." />
    <meta name="twitter:url" content="http://localhost:4000/2019/08/21/word-embeddings/" />
    
    <meta name="twitter:image" content="http://localhost:4000/assets/profile.JPG" />
    

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="shortcut icon" href="/favicon.ico">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">Jramkiss Blog</a>
      <nav class="site-nav">
        


<a class="page-link" href="/"> Posts </a>



    
    
        <a class="nav-link" href="/about/">About</a>
    



    
    
        <a class="nav-link" href="/contact/">Say Hello</a>
    



      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>First Steps with Word Embeddings</h1>
  <span class="post-meta">Aug 21, 2019</span><br>
  
  <span class="post-meta small">
  
    18 minute read
  
  </span>
</div>

<article class="post-content">
  <p>Accurately representing words as vectors is a challenging, but necessary task in machine learning. Consider the following sentences:</p>

<ul>
  <li>Jon is on the right</li>
  <li>Jon is right</li>
</ul>

<p>How can we accurately represent “right” with a single vector, when it means different things in different contexts?</p>

<p>This post will explain 3 breakthrough algorithms for learning word embeddings, and provide code examples for getting started with pre-trained models in Python. We’ll start with <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">word2vec</a>, which is the oldest of the 3, then explore ways of dealing with its shortcomings in <a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a> and <a href="https://arxiv.org/pdf/1607.04606.pdf">fasttext</a>.</p>

<p>Why use pre-trained models? - Pre-trained models are great because we don’t need a ton of resources to use powerful algorithms. Some of the models used here were trained by Google and Facebook on hundreds of millions of words. Pretty much impossible on a laptop CPU.</p>

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=3 orderedList=false} -->
<!-- code_chunk_output -->

<ul>
  <li><a href="#word2vec">Word2Vec</a>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#deep-dive">Deep Dive</a></li>
    </ul>
  </li>
  <li><a href="#glove">GloVe</a>
    <ul>
      <li><a href="#overview-1">Overview</a></li>
      <li><a href="#deep-dive-1">Deep Dive</a></li>
    </ul>
  </li>
  <li><a href="#fasttext">Fasttext</a>
    <ul>
      <li><a href="#overview-2">Overview</a></li>
      <li><a href="#deep-dive-2">Deep Dive</a></li>
    </ul>
  </li>
  <li><a href="#word-embeddings-in-python">Word Embeddings in Python</a>
    <ul>
      <li><a href="#word2vec-1">Word2vec</a></li>
      <li><a href="#glove-1">GloVe</a></li>
      <li><a href="#fasttext-1">Fasttext</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
  <li><a href="#appendix">Appendix</a></li>
</ul>

<!-- /code_chunk_output -->

<h2 id="word2vec">Word2Vec</h2>

<h3 id="overview">Overview</h3>

<p><a href="https://arxiv.org/pdf/1310.4546.pdf">Word2vec</a> really refers to one of two models for learning word vectors; the continuous bag-of-words (CBOW) or the skip-gram model. They are very similar, CBOW accepts context words as input and predicts the target word whereas the skip-gram accepts a target word as input and predicts a context word.</p>

<blockquote>
  <p>This inversion of predicting context / target words between CBOW and skip-gram might seem arbitrary, but it turns out that CBOW smoothes over distributional information by treating an entire context as one observation (useful for smaller datasets). Skip-gram on the other hand treats each context word - target word pair as a new observation, and tends to do better on larger data sets.</p>
</blockquote>

<p>Although we will primarily focus on the skip-gram, both models are single layer neural networks that accept one-hot encoded vectors as input. We learn the weights of the hidden layer, and each row of this weight matrix is a word vector. <strong>The model learns by simultaneously: (1) maximizing the probability that an observed word appears in the context of a target word and (2) minimizing the probability that a randomly selected word from the vocabulary appears in the context of the target word.</strong></p>

<p>If you’re still unsure about neural network weights and the weight matrix, I recommend reading <a href="http://neuralnetworksanddeeplearning.com/chap1.html">this chapter</a>.</p>

<h3 id="deep-dive">Deep Dive</h3>

<p>The main idea behind the skip-gram model is we take a word in an input sequence as the target word, and predict its context words. The context of a word is the $m$ words surrounding it. In figure 1, the window size is 2, the target word (“into”) is in red and its context words (“problems”, “turning”, “banking”, “crises”) are in blue.</p>

<p><br /></p>

<p><img src="/assets/word2vec_viz.png" alt="Figure1" />
Figure 1: The skip gram prediction of target word “into” with window size 2. Taken from Stanford’s NLP course, shows
 <br /></p>

<p>Before we start, let’s formalize some notation. We have an input sequence of words, $w_1, w_2,.., w_T$, each of which has a context window, $-m \le j \le m$. We’ll call this input sequence the <em>corpus</em>, and all its unique words the <em>vocabulary</em>. Each word in the vocabulary will have 2 vector representations, $u_o$ for context and $v_c$ for target.
In figure 1, $u_{turning}$ is the vector representation of “turning” as a context word, and $v_{banking}$ is the vector representation of “banking” as a target word.</p>

<p>We want to calculate the probability that each word in the window, $w_{t+j}$, appears in the context of the target word $w_t$. We’ll refer to this probability as $p(w_{t+j} \lvert w_t; \theta)$.<br />
This may seem weird, but the probability is based on the vector representations of each word. When we encounter a word in the context of another, we alter their vector representations to be “closer”. So the more we see words in each other’s context, the closer their vectors are. The function $J(\theta)$ below describes this; $\theta$ is a placeholder representing all the vector representations.</p>

<blockquote>
  <p>To see the intuition, we can forget about vectors: “turning” is more likely to be in the context of “into” than “crises” is (I can think of a million sentences with “turning into”, but not that many with “crises into” or “into crises”). So the vectors for “turning” and “into” should be to be closer than “crises” and “into”.</p>
</blockquote>

<script type="math/tex; mode=display">J(\theta) = -\frac{1}{T} \sum^{T}_{t = 1} \sum_{-m \le j \le m, j \ne 0} log(p(w_{t+j} \lvert w_t; \theta))</script>

<p>The only problem here is we have no idea how to find $p(w_{t+j} \lvert w_t; \theta)$. We’ll start with using the softmax function. This essentially calculates how similar a context word, $u_o$, is to target word $v_c$, relative to all other context words in the vocabulary. The measure of similarity between two words is measured by the dot product $u_o^T v_c$, and a larger dot product means more similar words.</p>

<script type="math/tex; mode=display">p(w_{t+j} \lvert w_t; \theta) = \frac{e^{u_o^T v_c}}{\sum_{w=1}^W e^{u_w^T v_c}}</script>

<p>Where:</p>

<ul>
  <li>$W$ is the size of the vocabulary</li>
  <li>$c$ and $o$ are indices of the words in the vocabulary at sequence positions $t$ and $j$ respectively</li>
  <li>$u_o = word2vec(w_{t+j})$</li>
  <li>$v_c = word2vec(w_t)$</li>
</ul>

<p>Although we now have a way of quantifying the probability a word appears in the context of another, the $\sum_{w=1}^W e^{u_w^T v_c}$ term requires us to iterate over all words in the vocabulary. To deal with this, we must approximate the softmax probability. One way of doing this is called negative sampling.</p>

<p><br /></p>

<h4 id="negative-sampling-loss">Negative Sampling Loss</h4>

<p>Negative sampling overcomes the need to iterate over all words in the vocabulary to compute the softmax by sub-sampling the vocabulary. We sample $k$ words and determine the probability that these words <strong>do not</strong> co-occur with the target word. The intuition behind this is that a good model should be able to differentiate between data and noise.</p>

<p>To incorporate negative sampling, the objective function needs to be altered by replacing $p(w_{t+j} \lvert w_t)$ with:</p>

<script type="math/tex; mode=display">log(\sigma(u_o^T v_c)) + \sum_{i = 1}^{k}E_{j \sim P(w)} [log(\sigma(-u_j^T v_c))]</script>

<p>Where $\sigma(.)$ is the <a href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid function</a>.</p>

<blockquote>
  <p>Thus the task is to distinguish the target word $w_t$ from draws from the noise distribution $P_n(w)$ using logistic regression, where there are $k$ negative samples for each data sample.</p>
</blockquote>

<p><br /></p>

<p><strong>New Objective Function</strong></p>

<script type="math/tex; mode=display">J(\theta) = \frac{-1}{T} \sum_{t=1}^{T}J_t(\theta)</script>

<script type="math/tex; mode=display">J_t(\theta) = log(\sigma(u_o^T v_c)) + \sum_{i = 1}^{k}E_{j \sim P(w)} [log(\sigma(-u_j^T v_c))]</script>

<script type="math/tex; mode=display">P(w) = U(w)^{3/4}/Z</script>

<p>Let’s look each component of $J_t(\theta)$ and try to convince ourselves this makes sense.</p>

<p><strong>The first part,</strong> $log(\sigma(u_o^Tv_c))$, can be interpreted as the log probability of the target and context words co-occurring. We want the model to find $u_o$ and $v_c$ to maximize this probability.</p>

<p><strong>The second part,</strong> $\sum_{i = 1}^{k}E_{j \sim P(w)} [log(\sigma(-u_j^T v_c))]$, is where the negative sampling happens. Let’s break this up more to make it clearer. It’ll come in handy to note that $\sigma(-x) = 1 - \sigma(x)$.</p>

<p>We can first drop the $E_{j \sim P(w)}$ term, since we already know we will be sampling words from some distribution, $P(w)$. We end up with:</p>

<script type="math/tex; mode=display">\sum_{i = 1}^{k} log(\sigma(-u_j^T v_c)) = \sum_{i = 1}^{k} log(1 - \sigma(u_j^T v_c))</script>

<p>Now this is easier to read, we’re taking the log of 1 minus the probability that the sampled word, $j$, appears in the context of the target word $c$. This is just log of the <em>probability that $j$ does <strong>not</strong> appear in the context of the target word</em> $c$. Since $j$ is randomly drawn out of ~$10^6$ words, there’s a very small chance it appears in the context of $c$, so this probability should be high. We do this for each of the $k$ sampled words.</p>

<p>Finally, we have to specify a distribution for negative sampling, $P(w) = U(w)^{3/4}/Z$. Here, $U(w)$ is the count of each word in the corpus (unigram distribution) and is raised to the $\frac{3}{4}$th power to sample rarer words in the vocabulary. $Z$ is just a normalization term to turn $P(w)$ into a probability distribution.</p>

<p>To summarize, this loss function is trying to maximize the probability that word $o$ appears in the context of word $c$, while minimizing the probability that a randomly selected word from the vocabulary does not appear in the context of word $c$. We use the gradient of this loss function to iteratively update the word vectors, $u_o$ and $v_c$ and eventually get our word embeddings.</p>

<p><a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/">Here</a> is a <em>great</em> tutorial on the skip-gram model!</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="glove">GloVe</h2>

<h3 id="overview-1">Overview</h3>

<p>GloVe (Global Vectors) is another architecture for learning word embeddings that improves on the skip-gram model by incorporating corpus statistics. Since the skip-gram model looks at each window independently, it loses corpus statistics. Instead, GloVe uses word co-occurrence counts to capture global information about the corpus. <strong>GloVe learns word embeddings by minimizing the difference between word vector dot products and their log co-occurrence counts.</strong></p>

<blockquote>
  <p>On the other hand, methods that rely solely on co-occurrence counts (eg: SVD on the co-occurrence matrix) fail to capture rich relationships between words. GloVe tries to incorporate the advantages of both the skip-gram model and count-based models.</p>
</blockquote>

<h3 id="deep-dive-1">Deep Dive</h3>

<h4 id="the-co-occurrence-matrix">The Co-Occurrence Matrix</h4>

<p>The co-occurrence matrix, $X$, is generated from the corpus and vocabulary. The entry at $X_{ij}$ is then the number of times word $j$ occurs in the context of word $i$. Context is defined in the same way as the skip-gram model. Summing over all the values in row $i$, will give the number of words that occur in its context, $X_i = \sum_k X_{ik}$. Then the probability of word $j$ occurring in the context of word $i$ is $P(i \lvert j) = \frac{X_{ij}}{X_i}$.</p>

<p>Below is the co-occurrence matrix for the corpus containing:</p>

<ul>
  <li>“I like deep learning.”</li>
  <li>“I like NLP.”</li>
  <li>“I enjoy flying.”</li>
</ul>

<p><img src="/assets/cooccurrence_matrix.png" alt="" /></p>

<h4 id="from-softmax-to-glove">From Softmax to GloVe</h4>

<p>We can find global loss using the softmax function, $Q_{ij}$, by summing over all target-context word pairs.</p>

<script type="math/tex; mode=display">J = - \sum_{i \in corpus} \sum_{j \in context} log (Q_{ij})</script>

<p>Since words $i$ and $j$ appear $X_{ij}$ times in the corpus, we don’t need to iterate over all windows in the corpus, but can iterate over the vocabulary and multiply by the co-occurrence count.</p>

<script type="math/tex; mode=display">J = - \sum_{i = 1}^{W} \sum_{j = 1}^{W} X_{ij} log Q_{ij}</script>

<p>Re-arranging some terms, we can come up with this:</p>

<script type="math/tex; mode=display">J = - \sum_{i = 1}^{W} X_{i} \sum_{j = 1}^{W} P_{ij}log(Q_{ij})</script>

<p><strong>What’s going on right now?</strong></p>

<ul>
  <li><strong>Where did $P_{ij}$ come from?</strong> - Remember that $P_{ij} = \frac{X_{ij}}{X_i}$ and $X_i = \sum_k X_{ik}$, therefore we can substitute $X_{ij} = P_{ij}X_i$.</li>
  <li><strong>What’s the relationship between $P_{ij}$ and $Q_{ij}$?</strong> - $P_{ij}$ is the probability that word $j$ appears in the context of word $i$, but $Q_{ij}$ is also the probability that word $j$ appears in the context of word $i$. The difference between the two lies in how they are calculated. $P_{ij}$ is calculated using the co-occurrence matrix and doesn’t change. $Q_{ij}$ is the naive softmax probability, that is calculated using the dot product of word vectors $u_j$ and $v_i$. We have the ability to change $Q_{ij}$ by changing these vectors.</li>
  <li><strong>What’s the point of $P_{ij}log(Q_{ij})$?</strong> - Now that we’ve refreshed our memory of $P$ and $Q$, we can see that $P$ is the <em>true</em> probability distribution of context and target words, and $Q$ is some made up distribution based on the “goodness” of the word vectors. We really want these two distributions to be close to each other. Observing $H = P_{ij}log(Q_{ij})$, when $P$ and $Q$ are close to each other, $H$ is small, and when $P$ and $Q$ are far apart, $H$ is larger. Our end goal is the minimization of $J$, so the smaller $H$ is is better. This is term is the cross-entropy between distributions $P$ and $Q$.</li>
</ul>

<blockquote>
  <p>Cross entropy error is just one among many possible distance measures between probability distributions, and it has the unfortunate property that distributions with long tails are often modeled poorly with too much weight given to the unlikely events.</p>
</blockquote>

<p>The problem here is that cross-entropy requires normalized versions of $Q_{ij}$ and $P_{ij}$ which we have to iterate over the entire vocabulary to calculate. This is the reason for using Negative Sampling in the skip-gram model. GloVe’s approach to this is dropping the normalization terms completely, so we end up with $\hat{P}$ and $\hat{Q}$. The cross-entropy function is now useless, so we change $H = P_{ij}log(Q_{ij})$ to a squared error function, $(\hat{P}<em>{ij} - \hat{Q}</em>{ij})^2$.</p>

<script type="math/tex; mode=display">\hat{J} = \sum_{i = 1}^{W} X_{i} \sum_{j = 1}^{W} (\hat{P}_{ij} - \hat{Q}_{ij})^2</script>

<p>Now we have squared error, weighted by the number of co-occurrences of words $i$ and $j$. There’s one last problem with this, which is that some co-occurrence counts can be massive. This will affect both the weights, $X_i$, and $\hat{P_{ij}} = X_{ij}$. To deal with this explosion in the squared term, we take $log(hat{P})$ and $log(hat{Q})$) and to deal with the explosion of weights, we introduce a function, $f$ that caps the co-occurrence count weight. We’ll apply $f$ to each target-context pair, $X_{ij}$ as opposed to only $X_i$. The new loss function becomes:</p>

<script type="math/tex; mode=display">\hat{J} = \sum_{w = 1}^{W} \sum_{w = 1}^{W} f(X_{ij}) (u_j^T v_i - log(X_{ij}))^2</script>

<p>This is the loss function that the GloVe model minimizes.</p>

<h2><br /></h2>
<p><br /></p>

<h2 id="fasttext">Fasttext</h2>

<h3 id="overview-2">Overview</h3>

<p><a href="https://github.com/facebookresearch/fastText">Fasttext</a> is a powerful library for learning word embeddings that was introduced by Facebook in 2016. Its roots come from the <a href="#deep-dive">word2vec</a> models.</p>

<p>Word2vec trains a unique vector for each word, ignoring important word sub-structure (morphological structure) and making out-of-vocabulary prediction nearly impossible. Fasttext attempts to solve this by treating each word as a sum of its subwords. These subwords can be defined in any way, however the simplest form is a character n-gram. Then the vector for each word is simply the sum of each of its n-grams. <strong>Fasttext learns word embeddings for each subword, then treats each word as a sum of its subwords.</strong></p>

<blockquote>
  <p>This is especially significant for morphologically rich languages (German, Turkish) in which a single word can have a large number of morphological forms, each of which might occur rarely, thus making it hard to train good word embeddings.</p>
</blockquote>

<h3 id="deep-dive-2">Deep Dive</h3>

<p>Before starting, we’ll take a step back to quantifying how similar two word vectors are. Both GloVe and word2vec do this using dot products, however we can think of the similarity more generally as an arbitrary function, $s(u_j, v_c)$.</p>

<p>Fasttext redefines this similarity measure, and represents words as a sum of smaller words, each of length n called n-grams. To help the model learn prefixes and suffixes, we append “&lt;” to the front and “&gt;” to the back of each word. Then for n=3, the n-grams of “where” are:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;where&gt; = [&lt;wh, whe, her, ere, re&gt;]
</code></pre></div></div>

<p>We have no way of determining the difference between the subword “her” and the full-word “her” (there definitely should be a difference). Appending the special characters around each word helps with this, as the tri-gram “her” is now different from the sequence “&lt;her&gt;”.</p>

<p>More formally, suppose we have all n-grams in the vocabulary, $G$, each represented by a vector, $\boldsymbol{z}_g$. We can refer to all the n-grams of some word, $w$, by $G_w$. Then $w$ can be represented as a sum of all n-grams. The new similarity function becomes:</p>

<script type="math/tex; mode=display">s(w, c) = \sum_{g \in G_w} \boldsymbol{z}_g^T v_c</script>

<p>We learn the embeddings of each character n-gram, then each word embedding is a sum of its n-gram vectors.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="word-embeddings-in-python">Word Embeddings in Python</h2>

<p>Now let’s explore word embeddings using pre-trained models in the <code class="highlighter-rouge">gensim</code> Python package. If you don’t have it installed, run <code class="highlighter-rouge">pip install gensim</code> in your command line. Gensim offers pre-trained models from their <code class="highlighter-rouge">gensim.downloader</code> method and each model used here embeds words in a 300-dimensional space. A full list of the models available can be found <a href="https://github.com/RaRe-Technologies/gensim-data">here</a>, or by running <code class="highlighter-rouge">python -m gensim.downloader --info</code> in your command line.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">gensim</span>
<span class="kn">import</span> <span class="nn">gensim.downloader</span> <span class="k">as</span> <span class="n">api</span>

<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c"># clearer images if you're using a Jupyter notebook</span>
<span class="o">%</span><span class="n">config</span> <span class="n">InlineBackend</span><span class="o">.</span><span class="n">figure_format</span><span class="o">=</span><span class="s">'retina'</span>
</code></pre></div></div>

<h3 id="word2vec-1">Word2vec</h3>

<p>For word2vec, we’ll use Google’s News dataset model, trained on news articles with a vocabulary of 3 million words and 300 dimensional embedding vectors. <a href="https://github.com/chrisjmccormick/inspect_word2vec">This repo</a> has an in-depth analysis of the words in the model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">word2vec_model_path</span> <span class="o">=</span> <span class="s">"word2vec-google-news-300"</span>
<span class="k">print</span><span class="p">(</span><span class="n">api</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">word2vec_model_path</span><span class="p">))</span>

<span class="n">word2vec_model</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">word2vec_model_path</span><span class="p">)</span>
<span class="n">w2v</span> <span class="o">=</span> <span class="n">word2vec_model</span><span class="o">.</span><span class="n">wv</span>

<span class="c"># remove from env</span>
<span class="k">del</span> <span class="n">word2vec_model</span>
</code></pre></div></div>

<h3 id="glove-1">GloVe</h3>

<p>The glove-wiki-gigaword-300 model used here is trained on 6B tokens from W ikipedia 2014 and the Gigaword dataset, other pre-trained GloVe models can be downloaded <a href="https://nlp.stanford.edu/projects/glove/">from Stanford</a> or <a href="https://github.com/RaRe-Technologies/gensim-data/releases/download/glove-wiki-gigaword-100">from Gensim</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glove_model_path</span> <span class="o">=</span> <span class="s">"glove-wiki-gigaword-300"</span>
<span class="k">print</span><span class="p">(</span><span class="n">api</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">glove_model_path</span><span class="p">))</span>

<span class="n">glove_model</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">glove_model_path</span><span class="p">)</span>
<span class="n">glove</span> <span class="o">=</span> <span class="n">glove_model</span><span class="o">.</span><span class="n">wv</span>

<span class="k">del</span> <span class="n">glove_model</span>
</code></pre></div></div>

<h3 id="fasttext-1">Fasttext</h3>

<p>Fasttext provides pre-trained models on for multiple languages, which can be used in different ways (through the command line, downloading the model, through <code class="highlighter-rouge">gensim</code>, etc.). We’ll use the English model provided by <code class="highlighter-rouge">Gensim</code> which is trained on wikipedia 2017 and news data, but you can go through <a href="https://github.com/facebookresearch/fastText/blob/master/docs/pretrained-vectors.md">their Github</a> to see more.</p>

<h4 id="word-comparison">Word Comparison</h4>

<p>Now we have vector representations for all words in the vocabulary in <code class="highlighter-rouge">wv</code> and can compare the different models. We’ll add and subtract some word vectors, then see what the closest word to the resulting vector is. Papers and blog posts have exhausted the “king” - “man” + “woman” = “queen” example, so I’ll present some new ones.</p>

<p>Results generated by the <code class="highlighter-rouge">find_most_similar</code> function are of the form (word, cosine similarity), where the each word is the closest to the one parsed into the function. Cosine similarity values closer to 1 means the vectors (words) are more similar. The function definition can be found in the <a href="#appendix">Appendix</a>.</p>

<p>Start with: <code class="highlighter-rouge">doctor - man + woman</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="p">(</span><span class="s">"word2vec: Doctor - Man + Woman"</span><span class="p">)</span>
<span class="n">find_most_similar</span><span class="p">(</span><span class="n">w2v</span><span class="p">[</span><span class="s">"doctor"</span><span class="p">]</span> <span class="o">-</span> <span class="n">w2v</span><span class="p">[</span><span class="s">"man"</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2v</span><span class="p">[</span><span class="s">"woman"</span><span class="p">],</span> <span class="n">w2v</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">"man"</span><span class="p">,</span> <span class="s">"doctor"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">])</span>

<span class="k">print</span> <span class="p">(</span><span class="s">"GloVe: Doctor - Man + Woman"</span><span class="p">)</span>
<span class="n">find_most_similar</span><span class="p">(</span><span class="n">glove</span><span class="p">[</span><span class="s">"doctor"</span><span class="p">]</span> <span class="o">-</span> <span class="n">glove</span><span class="p">[</span><span class="s">"man"</span><span class="p">]</span> <span class="o">+</span> <span class="n">glove</span><span class="p">[</span><span class="s">"woman"</span><span class="p">],</span> <span class="n">glove</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">"man"</span><span class="p">,</span> <span class="s">"doctor"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">])</span>

<span class="k">print</span> <span class="p">(</span><span class="s">"fasttext: Doctor - Man + Woman"</span><span class="p">)</span>
<span class="n">find_most_similar</span><span class="p">(</span><span class="n">fasttext</span><span class="p">[</span><span class="s">"doctor"</span><span class="p">]</span> <span class="o">-</span> <span class="n">fasttext</span><span class="p">[</span><span class="s">"man"</span><span class="p">]</span> <span class="o">+</span> <span class="n">fasttext</span><span class="p">[</span><span class="s">"woman"</span><span class="p">],</span> <span class="n">fasttext</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">"man"</span><span class="p">,</span> <span class="s">"doctor"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">])</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> word2vec: Doctor - Man + Woman
 [('gynecologist', 0.7276507616043091),
  ('nurse', 0.6698512434959412),
  ('physician', 0.6674120426177979)]  

 GloVe: Doctor - Man + Woman
 [('physician', 0.6203880906105042),
  ('nurse', 0.6161285638809204),
  ('doctors', 0.6017279624938965)]  

 fasttext: Doctor - Man + Woman
 [('gynecologist', 0.6874127388000488),
  ('nurse-midwife', 0.6773605346679688),
  ('physician', 0.6561880111694336)]
</code></pre></div></div>

<p>Interesting, what about if we make a subtle change to <code class="highlighter-rouge">doctor - woman + man</code>?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span> <span class="p">(</span><span class="s">"word2vec: Doctor - Woman + Man"</span><span class="p">)</span>
<span class="n">find_most_similar</span><span class="p">(</span><span class="n">w2v</span><span class="p">[</span><span class="s">"doctor"</span><span class="p">]</span> <span class="o">-</span> <span class="n">w2v</span><span class="p">[</span><span class="s">"woman"</span><span class="p">]</span> <span class="o">+</span> <span class="n">w2v</span><span class="p">[</span><span class="s">"man"</span><span class="p">],</span> <span class="n">w2v</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">"man"</span><span class="p">,</span> <span class="s">"doctors"</span><span class="p">,</span> <span class="s">"doctor"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">])</span>

<span class="k">print</span> <span class="p">(</span><span class="s">"GloVe: Doctor - Woman + Man"</span><span class="p">)</span>
<span class="n">find_most_similar</span><span class="p">(</span><span class="n">glove</span><span class="p">[</span><span class="s">"doctor"</span><span class="p">]</span> <span class="o">-</span> <span class="n">glove</span><span class="p">[</span><span class="s">"woman"</span><span class="p">]</span> <span class="o">+</span> <span class="n">glove</span><span class="p">[</span><span class="s">"man"</span><span class="p">],</span> <span class="n">glove</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">"man"</span><span class="p">,</span> <span class="s">"doctors"</span><span class="p">,</span> <span class="s">"doctor"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">,</span> <span class="s">"dr."</span><span class="p">])</span>

<span class="k">print</span> <span class="p">(</span><span class="s">"fasttext: Doctor - Woman + Man"</span><span class="p">)</span>
<span class="n">find_most_similar</span><span class="p">(</span><span class="n">fasttext</span><span class="p">[</span><span class="s">"doctor"</span><span class="p">]</span> <span class="o">-</span> <span class="n">fasttext</span><span class="p">[</span><span class="s">"woman"</span><span class="p">]</span> <span class="o">+</span> <span class="n">fasttext</span><span class="p">[</span><span class="s">"man"</span><span class="p">],</span> <span class="n">fasttext</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">"man"</span><span class="p">,</span> <span class="s">"doctors"</span><span class="p">,</span> <span class="s">"doctor"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">,</span> <span class="s">"dr."</span><span class="p">])</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>word2vec: Doctor - Woman + Man
[('physician', 0.6823904514312744),
 ('surgeon', 0.5908077359199524),
 ('dentist', 0.570309042930603)]  

GloVe: Doctor - Woman + Man  
[('physician', 0.5128607153892517),
 ('he', 0.4661550223827362),
 ('brother', 0.46356332302093506)]  

fasttext: Doctor - Woman + Man
[('physician', 0.6969557404518127),
 ('docter', 0.6826808452606201),
 ('non-doctor', 0.6698156595230103)]
</code></pre></div></div>

<p>This is a different results from the original results. Biases in the training data are expressed by the model. Also interestingly, there are some misspelled words in fasttext. This is because of the difference in learning methods.</p>

<h4 id="visualizing-embeddings">Visualizing Embeddings</h4>

<p>For the sake of completeness, I plotted words from different walks of life to see the algorithms were able to unravel their semantic similarities/differences. The first 2 principal components of each word vector are plotted. Some expected similarities are seen here, however we lose a lot of information from reducing the dimension from 300 to 2.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot_embeds</span><span class="p">([</span><span class="s">"dog"</span><span class="p">,</span> <span class="s">"cat"</span><span class="p">,</span> <span class="s">"hamster"</span><span class="p">,</span> <span class="s">"pet"</span><span class="p">]</span> <span class="o">+</span>                   <span class="c"># animals</span>
            <span class="p">[</span><span class="s">"boy"</span><span class="p">,</span> <span class="s">"girl"</span><span class="p">,</span> <span class="s">"man"</span><span class="p">,</span> <span class="s">"woman"</span><span class="p">]</span> <span class="o">+</span>                    <span class="c"># humans</span>
            <span class="p">[</span><span class="s">"grown"</span><span class="p">,</span> <span class="s">"adult"</span><span class="p">,</span> <span class="s">"young"</span><span class="p">,</span> <span class="s">"baby"</span><span class="p">]</span> <span class="o">+</span>                <span class="c"># age</span>
            <span class="p">[</span><span class="s">"german"</span><span class="p">,</span> <span class="s">"english"</span><span class="p">,</span> <span class="s">"spanish"</span><span class="p">,</span> <span class="s">"french"</span><span class="p">]</span> <span class="o">+</span>         <span class="c"># languages</span>
            <span class="p">[</span><span class="s">"mathematics"</span><span class="p">,</span> <span class="s">"physics"</span><span class="p">,</span> <span class="s">"biology"</span><span class="p">,</span> <span class="s">"chemistry"</span><span class="p">],</span>  <span class="c"># natural sciences</span>
            <span class="n">w2v</span><span class="p">,</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">"word2vec Embedding"</span><span class="p">)</span>
<span class="c"># run this again, but changing w2v to glove and fasttext</span>
</code></pre></div></div>

<p><img src="/assets/word2vec_embedding.png" alt="" />
<img src="/assets/glove_embedding.png" alt="" />
<img src="/assets/fasttext_embedding.png" alt="" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>Wrapping up, there are some key differences between word2vec (skip-gram), GloVe and fasttext. The skip-gram iterates over the corpus predicting context words given a target word. GloVe builds on this by incorporating global corpus statistics using word co-occurrences. The results are similar to word2vec. Fasttext also builds on word2vec by breaking each word into a sum of its sub-words. It learns vectors for each subword, then combines them for prediction. This allows out-of-vocabulary prediction, but introuces the risk of misspelled words.</p>

<p>Both word2vec and GloVe can be used as frameworks for learning general similarities in text without considering what each token is made of. This makes them useful for tasks like find similar movies given a sequence of movies watched by users. Fasttext on the other hand is more robust for translation tasks, where the likelihood of encountering an out-of-vocabulary is higher.</p>

<p><br /></p>

<hr />

<p><br /></p>

<h2 id="appendix">Appendix</h2>

<h4 id="code">Code</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># find the 3 most similar words to the vector "vec"</span>
<span class="k">def</span> <span class="nf">plot_embeds</span><span class="p">(</span><span class="n">word_list</span><span class="p">,</span> <span class="n">wv</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">word_embeddings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span> <span class="p">:</span>
    <span class="c"># pca on the embedding</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">wv</span><span class="p">[</span><span class="n">word_list</span><span class="p">])</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">word_list</span><span class="p">,</span> <span class="n">X</span><span class="p">)):</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.075</span><span class="p">,</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.075</span><span class="p">))</span>
    <span class="c"># Turn off tick labels</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>

<span class="k">def</span> <span class="nf">find_most_similar</span> <span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">wv</span><span class="p">,</span> <span class="n">words</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="p">:</span>
    <span class="c"># vec: resulting vector from word Arithmetic</span>
    <span class="c"># words: list of words that comprise vec</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">wv</span><span class="o">.</span><span class="n">similar_by_vector</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">topn</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
    <span class="c"># filter out words like "king" and "man", or else they will be included in the similarity</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">words</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span> <span class="p">:</span>
      <span class="n">word_sim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words</span><span class="p">),</span> <span class="n">s</span><span class="p">))[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">else</span> <span class="p">:</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">word_sim</span><span class="p">)</span>
</code></pre></div></div>

<hr />

</article>











      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Theme created by <a href="http://johnotander.com">John Otander</a> (<a href="https://twitter.com/4lpine">@4lpine</a>).
      Available on <a href="https://github.com/johnotander/pixyll">GitHub</a>.
    </small>
  </div>
</footer>

<script type="text/javascript">
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js")
    }
</script>

</body>
</html>
